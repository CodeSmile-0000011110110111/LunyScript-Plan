- The following Blocks raise internal events and should also be available to outside code interfacing with LunyScript:
	- Object enabled state (Unity: SetActive, Godot: paused) => OnEnable/OnDisable
	- Component enabled state => OnComponentEnable/OnComponentDisable
		- Note: needs design (ignore for now)
	- Instantiate/Destroy => OnCreate/OnDestroy
		- prefabs (user provides resource path or reference)
		- primitives (user provides primitive type via enum)
		- "empty" or built-in template objects (Unity: new GameObject, Godot: new Node)
	- Spawn/Despawn => OnSpawn/OnDespawn (get from and return to pool)
- Object Lifecycle Tracking
	- Godot: use global callbacks
	- Unity: rely on using internal blocks (raise relevant events), may add state-tracking later
- ContextRegistry
	- must provide fast access to script by engine-native object
-
-
- # LunyScript Object Lifecycle
- ## Event Execution Timing
- ### Object Creation
- **OnCreate**: Runs immediately when object is created (Unity: Awake, Godot: _init)
- **OnEnable**: Runs immediately after OnCreate (Unity: OnEnable, Godot: _enter_tree)
- **OnReady**: Runs once before first update (next frame by default) (Unity: Start, Godot: _ready)
	- Only runs once per object lifetime
	- Does NOT run again on re-enable
	- Execution order: Before OnFixedStep
- ### Regular Updates
- **OnFixedStep**: Every physics step (0-N times per frame) (Unity: FixedUpdate, Godot: _physics_process)
- **OnUpdate**: Once per frame (Unity: Update, Godot: _process)
- **OnLateUpdate**: Once per frame, after OnUpdate (Unity: LateUpdate, Godot: N/A)
- ### Object Destruction
- **OnDisable**: Runs immediately when disabled/destroyed (Unity: OnDisable, Godot: _exit_tree)
- **OnDestroy**: Deferred to end of frame (Unity: OnDestroy, Godot: N/A)
	- Runs after all OnLateUpdate calls complete
	- Processes all pending destroys in batch
- ## Participation Rules
- Created During Frame / Readied & Updating next frame
	- Objects created during a frame:
		- OnCreate => runs immediately
		- OnEnable => runs immediately
		- OnReady => next frame (runs once per lifetime, before OnUpdate and before OnFixedStep if the fixed step event runs in the current frame)
		- OnFixedStep => next frame
		- OnUpdate => next frame
		- OnLateUpdate => next frame
		- Note: this should be configurable to enable running whatever lifecycle update events follow the current event (follows Unity's model):
			- created in OnFixedStep => runs OnReady, OnUpdate, OnLateUpdate
			- created in OnUpdate => runs OnReady, OnLateUpdate (awkward but so be it)
			- created in OnLateUpdate => next frame, same as above
	- Objects destroyed during a frame:
		- current event runs to completion (object processing is single-threaded - if multithreaded in future we'll keep the "run to completion" behaviour)
		- OnDisable => runs immediately (if multithreaded: after object's event ran to completion)
		- subsequent events => won't run (see "disabled state" for the remainder of the frame)
		- OnDestroy => deferred to end of frame (after frame event processing completes, eg after all other objects have ran their OnLateUpdate)
	- Objects disabled during a frame:
		- OnDisable => runs immediately
		- subsequent events => won't run
		- behaviour of object and its children in disabled state:
			- not processing events (update, input, collision)
			- not participating in physics simulation
			- not rendering / not visible
	- Objects enabled during a frame (after being disabled before):
		- OnEnable => runs immediately
		- subsequent events => next frame (same as for create; OnReady does **not** run again)
	- Object created and disabled in same frame, or disabled/enabled multiple times per frame:
		- runs OnDisable/OnEnable as described above
		- final state at end of frame determines event handling in next frame
	- Object created and destroyed in same frame:
		- OnCreate => runs immediately
		- OnEnable => runs immediately
		- OnReady, OnFixedStep, OnUpdate, OnLateUpdate => won't run
		- subsequent events (input, collision, etc) => won't run
		- OnDisable => runs immediately
		- OnDestroy => deferred to end of frame
	- Object destroyed while disabled:
		- OnDisable => does not run again!
		- OnDestroy => deferred to end of frame
	- Scene unload (additive unload: only for objects in that scene; otherwise all objects affected)
		- cancel all pending creation queues
		- OnDisable => runs immediately
		- OnDestroy => runs immediately (including already pending destroyed events)
- Lifecycle Test cases
	- should simulate non-lifecycle events (eg collision) occuring before, during, and after current frame events to ensure correct order of execution
	- in various stages of scene updates (OnFixedStep, OnUpdate, OnLateUpdate) and various stages of object creation (OnCreate, OnEnable, OnReady, OnDisable, OnDestroy)
		- create object
		- destroy existing object
		- create and destroy object in same event
		- create and destroy object in same frame, different events (eg create in OnUpdate, destroy in OnLateUpdate)
		- enable object
		- disable object
		- enable/disable object multiple times in same event
		- enable/disable object multiple times in same frame, different events
		- create object and disable it in same event
		- create object and disable it in same frame, different events
		- disable object, then destroy disabled object
	- scene load/unload testing
		- additive: some objects unloaded, others remain
		- test with pending destroy events ()
	-